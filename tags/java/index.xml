<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Java - 标签 - jblj&#39;s Blog</title>
    <link>http://example.org/tags/java/</link>
    <description>Java - 标签 - jblj&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>965774771@qq.com (jblj)</managingEditor>
      <webMaster>965774771@qq.com (jblj)</webMaster><lastBuildDate>Tue, 31 Oct 2023 16:21:00 &#43;0800</lastBuildDate><atom:link href="http://example.org/tags/java/" rel="self" type="application/rss+xml" /><item>
  <title>Bridge设计模式</title>
  <link>http://example.org/bridge/</link>
  <pubDate>Tue, 31 Oct 2023 16:21:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/bridge/</guid>
  <description><![CDATA[试用Bridge模式完成下列事情：饮料的杯子有大、中、小；行为有：加奶，加糖，啥都不加。 Bridge 模式结构 桥机器模式的UML类图如下： Figure 1-1 桥接器类图 由上图可知，桥接器模式包含以下四个角色： Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个Implementor]]></description>
</item>
<item>
  <title>Builder设计模式</title>
  <link>http://example.org/builder/</link>
  <pubDate>Tue, 31 Oct 2023 16:16:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/builder/</guid>
  <description><![CDATA[修改本例，增加一个新的concrete的Builder。 Builder 模式结构 建造者模式的UML类图如下： Figure 1-1 Builder类图 由上图可知，建造者模式包含以下四个角色： Builder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用]]></description>
</item>
<item>
  <title>Abstract Factory设计模式</title>
  <link>http://example.org/abstract-factory/</link>
  <pubDate>Tue, 31 Oct 2023 16:10:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/abstract-factory/</guid>
  <description><![CDATA[阅读Abstract Factory的例子的代码，举例说明使用Abstract Factory模式的其他应用。 抽象工厂模式结构 Figure 1-1 抽象工厂模式类图 由上图可知，抽象工厂模式包含以下四个角色： AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 Produ]]></description>
</item>
<item>
  <title>Prototype设计模式</title>
  <link>http://example.org/prototype/</link>
  <pubDate>Tue, 31 Oct 2023 15:55:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/prototype/</guid>
  <description><![CDATA[请举例说明克隆模式的其他应用。 应用描述 使用克隆模式实现深克隆： 在图表对象（DataChart）中包含一个数据集对象(DataSet)。数据集对象用于封装要显示的数据，用户可以通过界面上的复制按钮将该图表复制一份，复制后即可得到新的图表对象，然后可以修改新图表的编号、颜色、数据。 UML类图 在该设计方案]]></description>
</item>
<item>
  <title>Factory Method设计模式</title>
  <link>http://example.org/factory-method/</link>
  <pubDate>Tue, 31 Oct 2023 15:45:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/factory-method/</guid>
  <description><![CDATA[改写本例，用于添加另一个具体工厂和具体产品。 工厂方法模式结构 Figure 1-1 工厂模式方法类图 具体类图 Figure 1-2 类图 抽象工厂和抽象产品 抽象工厂：Factory 是产生Product的抽象类，具体内容由ConcreteFactory决定。Factory对于实际产生的ConcreteProduct一无所知，唯一知道的就是调用]]></description>
</item>
<item>
  <title>Iterator设计模式</title>
  <link>http://example.org/iterator/</link>
  <pubDate>Tue, 31 Oct 2023 15:32:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/iterator/</guid>
  <description><![CDATA[针对Iterator的例子，将存储Book用的数组换成其他Collection并运行。 将数组存储方式换成ArrayList存储。 类图 img Aggregate接口 聚合定义创建相应迭代器对象的接口 1 2 3 public interface Aggregate{ public abstract Iterator iterator(); } Iterator接口 迭代器定义访问和遍历元素的接口 1 2 3 4 public interface Iterator { public abstract boolean hasNext(); public abstract Object next(); } Boo]]></description>
</item>
<item>
  <title>Adaptor设计模式</title>
  <link>http://example.org/adaptor/</link>
  <pubDate>Tue, 31 Oct 2023 15:24:00 &#43;0800</pubDate>
  <author>jblj</author>
  <guid>http://example.org/adaptor/</guid>
  <description><![CDATA[什么是双向适配器？ 在对象适配器使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类的方法，目标类也可以通过它调用适配者类的方法，那么该适配器就是一个双向适配器；即双向适配器类可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。 比如，单向适配器只能把交流]]></description>
</item>
</channel>
</rss>
